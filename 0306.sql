--뷰를 이용하여 최상위 보기
--데이터 순으로 보여짐
SELECT ROWNUM, E.* FROM EMP E;
--급여 내림차순으로 보여짐. 여기서 RONUM은 데이터 순서이지, DESC에 따른 순위가 아님
SELECT ROWNUM, E.*
  FROM EMP E
ORDER BY SAL DESC;
--ROWNUM은 테이블에 있는 열이 아닌 가상의 열
--
--급여 내림차순으로 정렬된 뷰   
--인라인뷰(서브쿼리 이용) -> 서브쿼리를 이용해서 먼저 정렬해놔야지 ROWNUM이 순위대로 정리가 됨
SELECT ROWNUM, E.*
  FROM (SELECT *
          FROM EMP E
        ORDER BY SAL DESC) E;
--인라인뷰(WITH절 이용) : 인라인뷰로 별칭쓰기 (위에와 같은 결과)
WITH E AS (SELECT * FROM EMP ORDER BY SAL DESC)
SELECT ROWNUM, E.* FROM E;
--인라인뷰(서브쿼리 이용)로 상위 3개 보기
SELECT ROWNUM, E.*
  FROM (SELECT *
          FROM EMP E
        ORDER BY SAL DESC) E
    WHERE ROWNUM <= 3;
--인라인뷰(WITH절 이용)로 상위 3개 보기
WITH E AS (SELECT * FROM EMP ORDER BY SAL DESC)
SELECT ROWNUM, E.* FROM E
    WHERE ROWNUM <= 3;
--

--시퀀스 = 연속 숫자를 생성하는 객체
--부서 정보 테이블의 열만 복사한 테이블 만들기
CREATE TABLE DEPT_SEQUENCE
    AS SELECT * FROM DEPT WHERE 1 != 1;
SELECT * FROM DEPT_SEQUENCE;
DROP TABLE DEPT_SEQUENCE;
--시퀀스 생성
CREATE SEQUENCE SEQ_DEPT_SEQUENCE
   INCREMENT BY 10
   START WITH 10
   MAXVALUE 90
   MINVALUE 0
   NOCYCLE
   CACHE 2;
   
--시퀀스 확인
SELECT * FROM USER_SEQUENCES;

--시퀀스에서 생성한 번호 사용하여 데이터 추가
--SEQ_DEPT_SEQUENCE.NEXTVAL: 다음 번호 생성
INSERT INTO DEPT_SEQUENCE (DEPTNO, DNAME, LOC)
VALUES (SEQ_DEPT_SEQUENCE.NEXTVAL, 'DATABASE', 'SEOUL');
SELECT * FROM DEPT_SEQUENCE ORDER BY DEPTNO;

--SEQ_DEPT_SEQUENCE.CURRVAL: 현재 번호 = 마지막으로 생성된 번호
SELECT SEQ_DEPT_SEQUENCE.CURRVAL FROM DUAL;

--실행만 7번
INSERT INTO DEPT_SEQUENCE (DEPTNO, DNAME, LOC)
VALUES (SEQ_DEPT_SEQUENCE.NEXTVAL, 'DATABASE', 'SEOUL');
SELECT * FROM DEPT_SEQUENCE ORDER BY DEPTNO;
--1번 더 실행하면 에러, 이미 최대값 도달했기 때문

--시퀀스 수정
ALTER SEQUENCE SEQ_DEPT_SEQUENCE
   INCREMENT BY 3
   MAXVALUE 99
   CYCLE;
--시퀀스 확인
SELECT * FROM USER_SEQUENCES;
--수정한 시퀀스 이용하여 데이터 추가
INSERT INTO DEPT_SEQUENCE (DEPTNO, DNAME, LOC)
VALUES (SEQ_DEPT_SEQUENCE.NEXTVAL, 'DATABASE', 'SEOUL');
SELECT * FROM DEPT_SEQUENCE ORDER BY DEPTNO;
--3번만 반복 실행
--최대값 도달, 다시 2번만 반복 실행
--CYCLE 로 설정하였기 때문에 시작번호(최소값)로 돌아감

--시퀀스 삭제
DROP SEQUENCE SEQ_DEPT_SEQUENCE;
--삭제한 시퀀스 확인
SELECT * FROM USER_SEQUENCES;
--

--동의어 SYNONYM
--동의어 = 공식적 별칭 = 일회성이 아님
--SELECT 나 FROM 절에서 사용하는 열이나 테이블의 별칭과 다름 = 일회성
--SQLPLUS에서 system/oracle 로 로그인
--SCOTT계정에게 동의어 생성 권한 부여 (PUBLIC도 포함)
sqlplus system/oracle
GRANT CREATE SYNONYM TO SCOTT;
GRANT CREATE PUBLIC SYNONYM TO SCOTT;
--sqldeveloper에서 SCOTT 계정으로 실행
CREATE SYNONYM E FOR EMP;
--동의어 사용
SELECT * FROM E;
--동의어 삭제
DROP SYNONYM E;
--삭제된 동의어 확인
SELECT * FROM E;
SELECT * FROM EMP;
--

--문제1-1
CREATE TABLE EMPIDX
 AS SELECT * FROM EMP;
SELECT * FROM EMPIDX;
--문제1-2
CREATE INDEX IDX_EMPIDX_EMPNO
 ON EMPIDX(EMPNO);
SELECT * FROM USER_IND_COLUMNS;
--문제1-3
SELECT * FROM USER_INDEXES;
SELECT * FROM USER_INDEXES WHERE INDEX_NAME = 'IDX_EMPIDX_EMPNO';
SELECT * FROM USER_IND_COLUMNS;

--문제2
--서브쿼리
SELECT EMPNO, ENAME, JOB, DEPTNO, SAL, NVL2(COMM,'O','X') AS COMM
   FROM EMPIDX
  WHERE SAL > 1500;
--
SELECT * FROM USER_VIEWS;
CREATE VIEW EMPIDX_OVER15K
 AS (SELECT EMPNO, ENAME, JOB, DEPTNO, SAL, NVL2(COMM,'O','X') AS COMM
   FROM EMPIDX
  WHERE SAL > 1500);
SELECT * FROM USER_VIEWS;
CREATE OR REPLACE VIEW EMPIDX_OVER15K
 AS (SELECT EMPNO, ENAME, JOB, DEPTNO, SAL, NVL2(COMM,'O','X') AS COMM
   FROM EMPIDX
  WHERE SAL > 1500);
SELECT * FROM USER_VIEWS;

--문제3-1
CREATE TABLE DEPTSEQ AS SELECT * FROM DEPT;
SELECT * FROM DEPTSEQ;
--문제3-2
CREATE SEQUENCE SEQ_DEPTSEQ_SEQUENCE
 START WITH 1
 INCREMENT BY 1
 MAXVALUE 99
 MINVALUE 1
 NOCYCLE
 NOCACHE;
SELECT * FROM USER_SEQUENCES;
--문제3-3
INSERT INTO DEPTSEQ
 VALUES(SEQ_DEPTSEQ_SEQUENCE.NEXTVAL,'DATABASE','SEOUL');
INSERT INTO DEPTSEQ
 VALUES(SEQ_DEPTSEQ_SEQUENCE.NEXTVAL,'WEB','BUSAN');
INSERT INTO DEPTSEQ
 VALUES(SEQ_DEPTSEQ_SEQUENCE.NEXTVAL,'MOBILE','ILSAN');
SELECT * FROM DEPTSEQ;
--

--제약조건
--빈값 허용하지 않음 = NOT NULL = 널값 불가
CREATE TABLE TABLE_NOTNULL(
   LOGIN_ID VARCHAR2(20) NOT NULL,
   LOGIN_PWD VARCHAR2(20) NOT NULL,
   TEL VARCHAR2(20)
);
SELECT * FROM TABLE_NOTNULL;
DESC TABLE_NOTNULL;
--빈 값 추가 안됨(제약조건에 어긋남)
INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PWD, TEL)
VALUES ('TEST_ID_01', NULL, '010-1234-5678');
SELECT * FROM TABLE_NOTNULL;
--빈 값 추가 됨(제약조건이 없음)
INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PWD)
VALUES ('TEST_ID_01', '1234');
SELECT * FROM TABLE_NOTNULL;
ROLLBACK;
--빈 값으로 변경 안됨(제약조건에 어긋남)
UPDATE TABLE_NOTNULL
   SET LOGIN_PWD = NULL
 WHERE LOGIN_ID = 'TEST_ID_01';
 
--제약조건 확인
--C: CHECK / NOT NULL, U: UNIQUE, P: PRIMARY, R: REFERENCE
SELECT * FROM USER_CONSTRAINTS;
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS;
--

--제약조건 이름 지정
CREATE TABLE TABLE_NOTNULL2(
   LOGIN_ID VARCHAR2(20) CONSTRAINT TBLNN2_LGNID_NN NOT NULL,
   LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLNN2_LGNPW_NN NOT NULL,
   TEL VARCHAR2(20)
);
--제약조건 확인
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS;
--
SELECT * FROM TABLE_NOTNULL;
--제약조건 추가 안됨(빈 값이 있음)
ALTER TABLE TABLE_NOTNULL
 MODIFY(TEL NOT NULL);
DESC TABLE_NOTNULL;
SELECT * FROM TABLE_NOTNULL;
--빈 값을 전화번호로 변경
UPDATE TABLE_NOTNULL
   SET TEL = '010-1234-5678'
 WHERE LOGIN_ID = 'TEST_ID_01';
SELECT * FROM TABLE_NOTNULL;
--재시도
ALTER TABLE TABLE_NOTNULL
 MODIFY(TEL NOT NULL);
DESC TABLE_NOTNULL;
SELECT * FROM TABLE_NOTNULL;

--제약조건 확인
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS;
--제약조건 이름 지정해서 추가
ALTER TABLE TABLE_NOTNULL2
MODIFY(TEL CONSTRAINT TBLNN_TEL_NN NOT NULL);
--제약조건 확인
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS;
DESC TABLE_NOTNULL2;
--
--제약조건 이름 변경
ALTER TABLE TABLE_NOTNULL2
RENAME CONSTRAINT TBLNN_TEL_NN TO TBLNN2_TEL_NN;
--변경된 제약조건 확인
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS;
--제약조건 삭제
ALTER TABLE TABLE_NOTNULL2
 DROP CONSTRAINT TBLNN2_TEL_NN;
--삭제된 제약조건 확인
DESC TABLE_NOTNULL2;
--삭제된 제약조건 확인
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS;
--

--중복 허용하지 않음 = UNIQUE
CREATE TABLE TABLE_UNIQUE(
   LOGIN_ID VARCHAR2(20) UNIQUE,
   LOGIN_PWD VARCHAR2(20) NOT NULL,
   TEL VARCHAR2(20)
);
SELECT * FROM TABLE_UNIQUE;
DESC TABLE_UNIQUE;
--제약조건 확인
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME = 'TABLE_UNIQUE';
 
--중복되는 데이터 추가
SELECT * FROM TABLE_UNIQUE;
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01', 'PWD01', '010-1234-5678');
SELECT * FROM TABLE_UNIQUE;
INSERT INTO TABLE_UNIQUE (LOGIN_ID, LOGIN_PWD, TEL)
VALUES ('TEST_ID_01', 'PWD01', '010-1234-5678');
--아이디가 중복되는 값은 추가할 수 없음(제약조건 UNIQUE)
--중복되는 데이터 추가
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_02', 'PWD01', '010-1234-5678');
SELECT * FROM TABLE_UNIQUE;
--비밀번호, 전화번호가 중복되는 값은 추가할 수 있음(제약조건 NOT NULL 이거나 아무것도 없음)

--빈 값 추가
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL)
VALUES(NULL, 'PWD01', '010-2345-6789');
SELECT * FROM TABLE_UNIQUE;
--아이디에 빈 값 추가 가능함, 중복불가는 빈값불가가 아님
--아이디가 중복되는 값으로 변경
SELECT * FROM TABLE_UNIQUE;
UPDATE TABLE_UNIQUE
   SET LOGIN_ID='TEST_ID_01'
 WHERE LOGIN_ID IS NULL;
--아이디가 중복되는 값은 변경 안됨(제약조건 UNIQUE)
--
DROP TABLE TABLE_UNIQUE;
--제약조건 이름 지정
CREATE TABLE TABLE_UNIQUE2(
   LOGIN_ID VARCHAR2(20) CONSTRAINT TBLUNQ2_LGNID_UNQ UNIQUE,
   LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLUNQ2_LGNPW_NN NOT NULL,
   TEL VARCHAR2(20)
);
--제약조건 확인
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';
ROLLBACK;
 --제약조건 추가
ALTER TABLE TABLE_UNIQUE
MODIFY(TEL UNIQUE);
--제약조건 확인
DESC TABLE_UNIQUE;
--중복되는 값이 있어 추가 안됨
--빈 값으로 변경
UPDATE TABLE_UNIQUE
   SET TEL = NULL;
SELECT * FROM TABLE_UNIQUE;
--제약조건 추가
ALTER TABLE TABLE_UNIQUE
MODIFY(TEL UNIQUE);
--제약조건 확인
DESC TABLE_UNIQUE;
--중복되는 값이 없어 추가됨
--제약조건 확인
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME = 'TABLE_UNIQUE';
--제약조건 이름 지정하여 추가
ALTER TABLE TABLE_UNIQUE2
MODIFY(TEL CONSTRAINT TBLUNQ_TEL_UNQ UNIQUE);
--이름 지정된 제약조건 확인
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';
 
 --제약조건 이름 변경
ALTER TABLE TABLE_UNIQUE2
RENAME CONSTRAINT TBLUNQ_TEL_UNQ TO TBLUNQ2_TEL_UNQ;
--제약조건 확인
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';
--제약조건 삭제
ALTER TABLE TABLE_UNIQUE2
 DROP CONSTRAINT TBLUNQ2_TEL_UNQ;
--삭제된 제약조건 확인
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';
--

--PRIMARY KEY = NOT NULL + UNIQUE = 유일하게 하나만 있는 값
CREATE TABLE TABLE_PK(
   LOGIN_ID VARCHAR2(20) PRIMARY KEY,
   LOGIN_PWD VARCHAR2(20) NOT NULL,
   TEL VARCHAR2(20)
);
DESC TABLE_PK;
--제약조건 확인
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME LIKE 'TABLE_PK%';
--PRIMARY KEY 생성하면 INDEX도 자동 생성됨
SELECT INDEX_NAME, TABLE_OWNER, TABLE_NAME
  FROM USER_INDEXES
 WHERE TABLE_NAME LIKE 'TABLE_PK%';
 --제약조건 이름 지정
CREATE TABLE TABLE_PK2(
   LOGIN_ID VARCHAR2(20) CONSTRAINT TBLPK2_LGNID_PK PRIMARY KEY,
   LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLPK2_LGNPW_NN NOT NULL,
   TEL VARCHAR2(20)
);
DESC TABLE_PK2;
--제약조건 확인
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME LIKE 'TABLE_PK%';
 
 --중복되는 값 추가
INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01', 'PWD01', '010-1234-5678');
SELECT * FROM TABLE_PK;
INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01', 'PWD02', '010-2345-6789');
--PRIMARY KEY = 중복 불가 + 빈값불가
--빈 값 추가
--명시적
INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES(NULL, 'PWD02', '010-2345-6789');
--암시적
INSERT INTO TABLE_PK(LOGIN_PWD, TEL)
VALUES('PWD02', '010-2345-6789');
--PRIMARY KEY = 중복 불가 + 빈값불가
--

--외래키 = 다른 테이블의 기본키를 참조
--제약조건 확인
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, R_OWNER, R_CONSTRAINT_NAME
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME IN ('EMP', 'DEPT');
--테이블 조회
SELECT * FROM EMP;
SELECT DISTINCT DEPTNO FROM EMP;
SELECT * FROM DEPT;
--
--외래키 열에 존재하지 않은 값 추가
INSERT INTO EMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES(9999, '홍길동', 'CLERK', '7788', TO_DATE('2017/04/30', 'YYYY/MM/DD'), 1200, NULL, 50);
--참조할 수 있는 값이 없기 때문에 추가 안됨

--실습 테이블 생성
--외래키 지정하기 위한 기본키 지정(DEPT)
CREATE TABLE DEPT_FK(
   DEPTNO NUMBER(2) CONSTRAINT DEPTFK_DEPTNO_PK PRIMARY KEY,
   DNAME VARCHAR2(14),
   LOC VARCHAR2(13)
);
DESC DEPT_FK;
--외래키 지정(EMP)
CREATE TABLE EMP_FK(
   EMPNO NUMBER(4) CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY,
   ENAME VARCHAR2(10),
   JOB VARCHAR2(9),
   MGR NUMBER(4),
   HIREDATE DATE,
   SAL NUMBER(7,2),
   COMM NUMBER(7,2),
   DEPTNO NUMBER(2) CONSTRAINT EMPFK_DEPTNO_FK REFERENCES DEPT_FK (DEPTNO)
);
DESC EMP_FK;
--


--테이블 조회
SELECT * FROM EMP_FK;
SELECT * FROM DEPT_FK;
--
--사원 정보 입력
INSERT INTO EMP_FK
VALUES(9999, 'TEST_NAME', 'TEST_JOB', NULL, TO_DATE('2001/01/01', 'YYYY/MM/DD'), 3000, NULL, 10);
--부서 정보에 참조할 부서 번호 10번이 없기 때문에 입력이 안됨
--부서 정보 입력
INSERT INTO DEPT_FK
VALUES(10, 'TEST_DNAME', 'TEST_LOC');
SELECT * FROM DEPT_FK;
--참조할 수 있는 부서번호 값이 먼저 있어야 함
--사원 정보 재입력
INSERT INTO EMP_FK
VALUES(9999, 'TEST_NAME', 'TEST_JOB', NULL, TO_DATE('2001/01/01', 'YYYY/MM/DD'), 3000, NULL, 10);
SELECT * FROM EMP_FK;
--부서 정보에 참조할 부서 번호 10번이 존재하기 때문에 입력이 됨
--생성 순서
--1) 참조할 기본 키 생성(예, DEPT_FK)
--2) 기본키 참조할 참조키 생성(예, EMP_FK)
--3) 참조할 기본키에 데이터 입력(예, 부서번호 10번)
--4) 기본키 참조할 참조키에 데이터 입력(예, 10번 부서 소속의 TEST_NAME이라는 사원)
--

--삭제
DELETE FROM DEPT_FK
 WHERE DEPTNO = 10;
--EMP 테이블에서 참조하고 있기 때문에 삭제가 안됨
--
--삭제 순서
--1) 기본키 참조할 참조키에 데이터 삭제(예, 10번 부서 소속의 TEST_NAME이라는 사원)
--2) 참조할 기본키에 데이터 삭제(예, 부서번호 10번)
--다른 방법
--1) 기본키 참조할 참조키에 데이터 변경(예, 10번 부서 소속의 TEST_NAME이라는 사원의 부서 번호를 다른 번호로 변경하거나 빈 값으로 변경)
--2) 참조할 기본키에 데이터 삭제(예, 부서번호 10번)
--
--참조키 제약조건 해제가 번거로울 때, 제약조건 삭제 옵션 지정 가능
--1) 참조하고 있는 데이터 삭제: 예, CONSTRAINT EMPFK_DEPTNO_FK REFERENCES DEPT_FK (DEPTNO) ON DELETE CASCADE
--2) 참조하고 있는 데이터 빈 값으로 변경: 예, CONSTRAINT EMPFK_DEPTNO_FK REFERENCES DEPT_FK (DEPTNO) ON DELETE SET NULL
--


--값의 범위나 패턴을 정의할 때 사용 = CHECK
CREATE TABLE TABLE_CHECK(
   LOGIN_ID VARCHAR2(20) CONSTRAINT TBLCK_LOGINID_PK PRIMARY KEY,
   LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLCK_LOGINPW_CK CHECK (LENGTH(LOGIN_PWD) > 3),
   TEL VARCHAR2(20)
);
DESC TABLE_CHECK;
--CHECK 조건에 맞지 않는 데이터 입력
INSERT INTO TABLE_CHECK
VALUES ('TEST_ID', '123', '010-1234-5678');
--CHECK 조건에 맞는 데이터 입력
INSERT INTO TABLE_CHECK
VALUES ('TEST_ID', '1234', '010-1234-5678');
SELECT * FROM TABLE_CHECK;
--제약조건 확인
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME = 'TABLE_CHECK';
--

-- 기본값 지정 = DEFAULT
CREATE TABLE TABLE_DEFAULT(
   LOGIN_ID VARCHAR2(20) CONSTRAINT TBLCK2_LOGINID_PK PRIMARY KEY,
   LOGIN_PWD VARCHAR2(20) DEFAULT '1234',
   TEL VARCHAR2(20)
);
DESC TABLE_DEFAULT;
--명시적 빈 값 추가
INSERT INTO TABLE_DEFAULT VALUES ('TEST_ID', NULL, '010-1234-5678');
SELECT * FROM TABLE_DEFAULT;
--암시적 빈 값 추가
INSERT INTO TABLE_DEFAULT (LOGIN_ID, TEL) VALUES ('TEST_ID2', '010-1234-5678');
SELECT * FROM TABLE_DEFAULT;
--
INSERT INTO TABLE_DEFAULT VALUES ('TEST_ID3', 'CONNI2', '010-1234-5678');
SELECT * FROM TABLE_DEFAULT;
--실무에서 여러가지 테스트하는 경우가 많은데, 제약조건으로 불편한 경우가 많음
--제약조건 활성화 / 비활성화 를 통해 사용 가능함
--ALTER TABLE 테이블 이름 ENABLE CONSTRAINT 제약조건 이름; (활성화)
--ALTER TABLE 테이블 이름 DISABLE CONSTRAINT 제약조건 이름; (비활성화)
--


CREATE TABLE DEPT_CONST(
   DEPTNO NUMBER(2) CONSTRAINT DEPTCONST_DEPTNO_PK PRIMARY KEY,
   DNAME VARCHAR2(14) CONSTRAINT DEPTCONST_DNAME_UNQ UNIQUE,
   LOC VARCHAR2(13) CONSTRAINT DEPTCONST_LOC_NN NOT NULL
);
SELECT * FROM DEPT_CONST;

CREATE TABLE EMP_CONST(
    EMPNO NUMBER(4) CONSTRAINT EMPCONST_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10) CONSTRAINT EMPCONST_ENAME_NN NOT NULL,
    JOB VARCHAR2(9),
    TEL VARCHAR2(20) CONSTRAINT EMPCONST_TEL_UNQ UNIQUE,
    HIREDATE DATE,
    SAL NUMBER(7,2) CONSTRAINT EMPCONST_SAL_CHK CHECK(SAL > 1000 AND SAL < 9999),
    COMM NUMBER(7,2),
    DEPTNO NUMBER(2) CONSTRAINT EMPCONST_DEPTNO_FK REFERENCES DEPT_CONST(DEPTNO)
);

--문제1-3
SELECT TABLE_NAME, CONSTRAINT_NAME CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME IN ('EMP_CONST', 'DEPT_CONST')
 ORDER BY CONSTRAINT_NAME;
--

--권한 관리
--시스템 권한
--SQLPLUS에서 system/oracle 로 실행
--사용자 생성
CREATE USER ORCLSTUDY
IDENTIFIED BY ORACLE;
--데이터베이스 관리자 권한으로 사용자 생성
--SQLPLUS에서 실행
CONN ORCLSTUDY/ORACLE;

--SQLPLUS에서 system/oracle 로 실행
--권한 부여
CONN system/oracle;
GRANT RESOURCE, CREATE SESSION, CREATE TABLE TO ORCLSTUDY;


--SQLPLUS에서 ORCLSTUDY/ORACLE 로 실행
--계정 연결
CONN ORCLSTUDY/ORACLE;

--테이블 생성, 데이터 추가, 조회
CREATE TABLE TEMP1(
COL1 VARCHAR2(20),
COL2 VARCHAR2(20)
);
INSERT INTO TEMP1 VALUES('USER','TEST');
SELECT * FROM TEMP1;
--권한이 있기 때문에 잘 실행됨

--SQLPLUS에서 system/oracle 로 실행
--RESOURCE 롤과 CREATE TABLE 권한 취소
CONN system/oracle;
REVOKE RESOURCE, CREATE TABLE FROM ORCLSTUDY;
--SQLPLUS에서 ORCLSTUDY/ORACLE 로 실행
--계정 연결
CONN ORCLSTUDY/ORACLE;
--테이블 생성
CREATE TABLE TEMP1(
COL1 VARCHAR2(20),
COL2 VARCHAR2(20)
);
--연결은 되지만 RESOURCE 롤과 테이블 생성할 수 있는 권한이 없어 생성할 수 없음

--객체 권한
--SQLPLUS에서 scott/tiger 로 실행
--테이블 생성, 조회
CONN scott/tiger
CREATE TABLE TEMP(
   COL1 VARCHAR(20),
   COL2 VARCHAR(20)
);
SELECT * FROM TEMP;
--ORCLSTUDY 계정에게 권한 부여
--동시에 부여 가능
GRANT SELECT, INSERT ON TEMP
   TO ORCLSTUDY;
--SELECT 권한
--GRANT SELECT ON TEMP TO ORCLSTUDY;
--INSERT 권한
--GRANT INSERT ON TEMP TO ORCLSTUDY;
--SQLPLUS에서 ORCLSTUDY/ORACLE 로 실행

--롤 관리
--SQLPLUS에서 system/oracle 로 실행
--롤 생성
CONN system/oracle;
CREATE ROLE ROLESTUDY;
--권한 부여
GRANT CONNECT, RESOURCE, CREATE VIEW, CREATE SYNONYM
   TO ROLESTUDY;
--롤 부여
GRANT ROLESTUDY TO ORCLSTUDY;


--SQLPLUS에서 ORCLSTUDY/ORACLE 로 실행
--계정 연결
CONN ORCLSTUDY/ORACLE;
--부여된 롤과 권한 확인
SELECT * FROM USER_SYS_PRIVS;
SELECT * FROM USER_ROLE_PRIVS;
--SQLPLUS에서 system/oracle 로 실행
--롤 취소
CONN system/oracle;
REVOKE ROLESTUDY FROM ORCLSTUDY;
--취소된 내용 확인
--SQLPLUS에서 ORCLSTUDY/ORACLE 로 실행
--계정 연결
CONN ORCLSTUDY/ORACLE;
--부여된 롤 확인
SELECT * FROM USER_ROLE_PRIVS;
--롤이 취소됨
--SQLPLUS에서 system/oracle 로 실행
--롤 삭제
CONN system/oracle;
DROP ROLE ROLESTUDY;
--

--연습 문제
CREATE USER PREV_HW
IDENTIFIED BY ORCL;
CONN system/oracle;
GRANT CREATE SESSION PREV_HW;
--

CONN scott/tiger;


--문제 1번
--SQLPLUS에서 system/oracle 로 실행
--사용자 생성
sqlplus system/oracle
CREATE USER PREV_HW
  IDENTIFIED BY ORCL;
--접속 권한 부여
GRANT CREATE SESSION TO PREV_HW;
--접속
EXIT
sqlplus PREV_HW/ORCL
--

--문제 2번
--SQLPLUS에서 scott/tiger 로 실행
--SELECT 권한 부여
CONN scott/tiger;
GRANT SELECT ON EMP TO PREV_HW;
GRANT SELECT ON DEPT TO PREV_HW;
GRANT SELECT ON SALGRADE TO PREV_HW;
--접속
CONN PREV_HW/ORCL;
--SELECT 실행
SELECT * FROM SCOTT.EMP;
SELECT * FROM SCOTT.DEPT;
SELECT * FROM SCOTT.SALGRADE;


--문제 3번
--SQLPLUS에서 scott/tiger 로 실행
--SALGRADE 테이블 SELECT 권한 취소
CONN scott/tiger;
REVOKE SELECT ON SALGRADE FROM PREV_HW;
--접속
CONN PREV_HW/ORCL;
--SELECT 실행
SELECT * FROM SCOTT.SALGRADE;
--