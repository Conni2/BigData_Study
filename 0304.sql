--그룹화와 관련된 함수 (GROUPBY)
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
    FROM EMP
    GROUP BY DEPTNO, JOB
    ORDER BY DEPTNO, JOB;
    
--열의 개수 + 1만큼 결과 출력 (ROLLUP)
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
    FROM EMP
    GROUP BY ROLLUP(DEPTNO, JOB);
    
    --2의 열의 개수 제곱만큼 결과 출력 (CUBE)
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
    FROM EMP
    GROUP BY CUBE(DEPTNO, JOB)
    ORDER BY DEPTNO, JOB;
    
--첫번째 열 그룹화하여 부분합 (ROLLUP 에 사용되는 곳은 부분합이 나오지 않음)
SELECT DEPTNO, JOB, COUNT(*)
    FROM EMP
    GROUP BY DEPTNO, ROLLUP(JOB);
--얘는 이번에 ROLLUP안에는 DEPTNO가 들어갔으니까 DEPTNO의 부분합이 나오지 않았고 JOB이 나왔음
SELECT DEPTNO, JOB, COUNT(*)
    FROM EMP
    GROUP BY JOB, ROLLUP(DEPTNO);
    
--열을 따로 그룹화하여 출력
SELECT DEPTNO, JOB, COUNT(*)
    FROM EMP
    GROUP BY GROUPING SETS(DEPTNO, JOB)
    ORDER BY DEPTNO, JOB;
    
--GROUPING
--그룹화 상태 알려줌(그룹화된 것이 0)
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL),
       GROUPING(DEPTNO),
       GROUPING(JOB)
  FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

-- CUBE의 결과를 GROUPING 과 DECODE문법을 써서 구현해보기
--CUBE의 결과를 GROUPING함수 이용하여 DECODE문으로 구현
SELECT DECODE(GROUPING(DEPTNO), 1, 'ALL_DEPT', DEPTNO) AS DEPTNO, 
       DECODE(GROUPING(JOB), 1, 'ALL_JOB', JOB) AS JOB, --DECODE사용되었다면 JOB을 그대로
       COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
  FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

--그룹화 상태 알려줌(0, 1의 조합)
SELECT DEPTNO, JOB, COUNT(*), SUM(SAL),
       GROUPING(DEPTNO),
       GROUPING(JOB),
       GROUPING_ID(DEPTNO, JOB)
  FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;
--

--PIVOT: 행을 열로 바꿈
SELECT DEPTNO, JOB, MAX(SAL)
    FROM EMP
    GROUP BY DEPTNO, JOB
    ORDER BY DEPTNO, JOB;
--DEPTNO를 행에서 열로
SELECT *
    FROM(SELECT DEPTNO, JOB, SAL FROM EMP)
    PIVOT(MAX(SAL)
          FOR DEPTNO IN (10,20, 30)) --원래는 행이었는데 이게 열이 됨
    ORDER BY JOB;
--JOB을 행에서 열로
SELECT *
    FROM(SELECT DEPTNO, JOB, SAL FROM EMP)
    PIVOT(MAX(SAL)
          FOR JOB IN ('CLERK' AS CLERK,
                      'MANAGER' AS MANAGER,
                      'PRESIDENT' AS PRESIDENT,
                      'ANALYST' AS ANALYST,
                      'SALESMAN' AS SALESMAN))
    ORDER BY DEPTNO;
--DECODE 로 PIVOT -> PIVOT을 DECODE로도 할 수 있음
SELECT DEPTNO,
       MAX(DECODE(JOB, 'CLERK', SAL)) AS CLERK,
       MAX(DECODE(JOB, 'SALESMAN', SAL)) AS SALESMAN,
       MAX(DECODE(JOB, 'PRESIDENT', SAL)) AS PRESIDENT,
       MAX(DECODE(JOB, 'MANAGER', SAL)) AS MANAGER,
       MAX(DECODE(JOB, 'ANALYST', SAL)) AS ANALYST
  FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;

--UNPIVOT: 열을 행으로 바꿈
SELECT *
  FROM(SELECT DEPTNO,
              MAX(DECODE(JOB, 'CLERK' , SAL)) AS "CLERK",
              MAX(DECODE(JOB, 'SALESMAN' , SAL)) AS "SALESMAN",
              MAX(DECODE(JOB, 'PRESIDENT', SAL)) AS "PRESIDENT",
              MAX(DECODE(JOB, 'MANAGER' , SAL)) AS "MANAGER",
              MAX(DECODE(JOB, 'ANALYST' , SAL)) AS "ANALYST"
         FROM EMP
       GROUP BY DEPTNO
       ORDER BY DEPTNO)
UNPIVOT(
   SAL FOR JOB IN (CLERK, SALESMAN, PRESIDENT, MANAGER, ANALYST))
ORDER BY DEPTNO, JOB;
--

-- 연습문제
--문제1
SELECT DEPTNO,
       TRUNC(AVG(SAL)) AS AVG_SAL,
       MAX(SAL) AS MAX_SAL,
       MIN(SAL) AS MIN_SAL,
       COUNT(*) AS CNT
    FROM EMP
   GROUP BY DEPTNO;
--문제2
SELECT JOB, COUNT(*)
    FROM EMP
   GROUP BY JOB
   HAVING COUNT(*) >= 3;
--문제3
SELECT TO_CHAR(HIREDATE, 'YYYY') AS HIRE_YEAR,
       DEPTNO,
       COUNT(*) AS CNT
    FROM EMP
   GROUP BY TO_CHAR(HIREDATE, 'YYYY'), DEPTNO;
--문제4
SELECT NVL2(COMM, 'O', 'X') AS EXIST_COMM,
       COUNT(*) AS CNT
    FROM EMP
   GROUP BY NVL2(COMM, 'O', 'X');
--문제5
SELECT DEPTNO,
       TO_CHAR(HIREDATE, 'YYYY') AS HIRE_YEAR,
       COUNT(*) AS CNT,
       MAX(SAL) AS MAX_SAL,
       SUM(SAL) AS SUM_SAL,
       AVG(SAL) AS AVG_SAL
    FROM EMP
   GROUP BY ROLLUP(DEPTNO, TO_CHAR(HIREDATE, 'YYYY'));
--
--여러 테이블을 하나의 테이블처럼 사용하는 조인
--14 rows
SELECT *
  FROM EMP
 ORDER BY EMPNO;
--4 rows
SELECT *
  FROM DEPT
 ORDER BY DEPTNO;
--14*4=56 rows -> 이 조인은 모든 조합의 결과임 : 이를 DEPTNO_1이 같은 것만 JOIN 해야한다는 조건이 필요함
SELECT *
  FROM EMP, DEPT
 ORDER BY EMPNO;
 
--내부조인 = 등가조인 = 단순조인
--보통 말하는 조인의 경우에 해당함
SELECT *
  FROM EMP, DEPT
 WHERE EMP.DEPTNO = DEPT.DEPTNO
ORDER BY EMPNO;
--테이블 별칭 사용
SELECT *
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
ORDER BY EMPNO;
--열을 구체적으로 명시
SELECT * FROM EMP;
SELECT * FROM DEPT;
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO,
       D.DNAME, D.LOC
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
ORDER BY EMPNO;
--

--동시에 같은 열을 가지고 있는 경우
SELECT EMPNO, ENAME, DEPTNO, DNAME, LOC
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO;
--열의 출처를 구체적으로 명시해야 함
SELECT EMPNO, ENAME, D.DEPTNO, DNAME, LOC
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO;
--조건 추가
--조건은 반드시 최소 테이블 개수 - 1개 만큼 필요함
SELECT E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
   AND SAL >= 3000;
--문제
SELECT E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
   AND SAL <= 2500
   AND EMPNO <= 9999;
--

--비등가조인 = 등가조인 이외의 조인 방식
SELECT *
    FROM EMP;
SELECT *
    FROM SALGRADE;
--
SELECT *
  FROM EMP E, SALGRADE S
 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;
 
--자체 조인 = 같은 테이블끼리 조인
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
  FROM EMP E1, EMP E2
 WHERE E1.MGR = E2.EMPNO;
 
 --외부조인
--LEFT OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
  FROM EMP E1, EMP E2
 WHERE E1.MGR = E2.EMPNO(+)
ORDER BY E1.EMPNO;
--직속상관이 없는 사람도 나옴
--RIGHT OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
  FROM EMP E1, EMP E2
 WHERE E1.MGR(+) = E2.EMPNO
ORDER BY E1.EMPNO;
--부하직원이 없는 사람도 나옴

--JOIN ~ ON
--조인할 공통 열을 지정해야 함 = 같다는 조건으로
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO, D.DNAME, D.LOC
  FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO)
 WHERE SAL <= 3000
ORDER BY E.DEPTNO, EMPNO;

--LEFT OUTER JOIN ON
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
  FROM EMP E1 JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;

--OUTER JOIN ON
--LEFT OUTER JOIN ON
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
  FROM EMP E1 LEFT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;
--RIGHT OUTER JOIN ON
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
  FROM EMP E1 RIGHT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;
--FULL OUTER JOIN ON
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
  FROM EMP E1 FULL OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO;
--직속상관이 없는 사람 + 부하직원이 없는 사람
--

--문제1
--SQL-99 이전 방식
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
    FROM DEPT D, EMP E
   WHERE D.DEPTNO = E.DEPTNO
     AND E.SAL > 2000
   ORDER BY D.DEPTNO;
   
--SQL-99 방식
SELECT DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
  FROM EMP E NATURAL JOIN DEPT D
 WHERE E.SAL > 2000
 ORDER BY DEPTNO;
SELECT DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
  FROM EMP E JOIN DEPT D USING(DEPTNO)
 WHERE E.SAL > 2000
 ORDER BY DEPTNO;
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
    FROM DEPT D JOIN EMP E ON (D.DEPTNO = E.DEPTNO)
   WHERE E.SAL > 2000
   ORDER BY D.DEPTNO;

--문제2
--SQL-99 이전 방식
SELECT D.DEPTNO, D.DNAME,
       TRUNC(AVG(SAL)) AS AVG_SAL,
       MAX(SAL) AS MAX_SAL,
       MIN(SAL) AS MIN_SAL,
       COUNT(*) AS CNT
    FROM DEPT D, EMP E
   WHERE D.DEPTNO = E.DEPTNO
  GROUP BY D.DEPTNO, D.DNAME;
  
--SQL-99 방식
SELECT DEPTNO, D.DNAME,
       TRUNC(AVG(SAL)) AS AVG_SAL,
       MAX(SAL) AS MAX_SAL,
       MIN(SAL) AS MIN_SAL,
       COUNT(*) AS CNT
  FROM EMP E NATURAL JOIN DEPT D
 GROUP BY DEPTNO, D.DNAME;
SELECT DEPTNO, D.DNAME,
       TRUNC(AVG(SAL)) AS AVG_SAL,
       MAX(SAL) AS MAX_SAL,
       MIN(SAL) AS MIN_SAL,
       COUNT(*) AS CNT
  FROM EMP E JOIN DEPT D USING(DEPTNO)
 GROUP BY DEPTNO, D.DNAME;
SELECT D.DEPTNO, D.DNAME,
       TRUNC(AVG(SAL)) AS AVG_SAL,
       MAX(SAL) AS MAX_SAL,
       MIN(SAL) AS MIN_SAL,
       COUNT(*) AS CNT
    FROM DEPT D JOIN EMP E ON (D.DEPTNO = E.DEPTNO)
   GROUP BY D.DEPTNO, D.DNAME;
   
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
        FROM DEPT D LEFT OUTER JOIN EMP E ON (D.DEPTNO = E.DEPTNO);
        
--문제3
--SQL-99 이전 방식
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
     FROM DEPT D, EMP E
    WHERE D.DEPTNO = E.DEPTNO(+)
   ORDER BY D.DEPTNO, E.ENAME;
--SQL-99 방식
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
     FROM DEPT D LEFT OUTER JOIN EMP E ON (D.DEPTNO = E.DEPTNO)
    ORDER BY D.DEPTNO, E.ENAME;

--문제4
--SQL-99 이전 방식
SELECT D.DEPTNO, D.DNAME,
       E1.EMPNO, E1.ENAME, E1.MGR, E1.SAL, E1.DEPTNO,
       S.LOSAL, S.HISAL, S.GRADE,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
    FROM DEPT D, EMP E1, SALGRADE S, EMP E2
   WHERE D.DEPTNO = E1.DEPTNO(+)
     AND E1.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
     AND E1.MGR = E2.EMPNO(+)
   ORDER BY D.DEPTNO, E1.EMPNO;
--SQL-99 방식
SELECT D.DEPTNO, D.DNAME,
       E1.EMPNO, E1.ENAME, E1.MGR, E1.SAL, E1.DEPTNO,
       S.LOSAL, S.HISAL, S.GRADE,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
    FROM DEPT D LEFT OUTER JOIN EMP E1 ON (D.DEPTNO = E1.DEPTNO)
                LEFT OUTER JOIN SALGRADE S ON (E1.SAL BETWEEN S.LOSAL AND S.HISAL)
                LEFT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
   ORDER BY D.DEPTNO, E1.EMPNO;

--WHERE절 뒤에서 사용하는 서브 쿼리
--단일행서브쿼리
SELECT SAL
  FROM EMP
 WHERE ENAME = 'JONES';
--
SELECT *
  FROM EMP
 WHERE SAL > 2975;
--
SELECT *
  FROM EMP
 WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME = 'JONES');
 
 --단일행서브쿼리 & 날짜형 데이터
SELECT *
  FROM EMP
 WHERE HIREDATE < (SELECT HIREDATE
                     FROM EMP
                    WHERE ENAME = 'SCOTT');
                    
--다중행서브쿼리
--다중행 연산자 IN
SELECT *
  FROM EMP
 WHERE DEPTNO IN (20, 30);
--부서 별 가장 많이 받는 사람
SELECT *
  FROM EMP
 WHERE SAL IN (SELECT MAX(SAL)
                 FROM EMP
               GROUP BY DEPTNO);
--같다는 OR 조건 여러 개와 동일   
--다중행 연산자 ANY
SELECT *
  FROM EMP
 WHERE SAL = ANY (SELECT MAX(SAL)
                    FROM EMP
                  GROUP BY DEPTNO);
--다중행 연산자 SOME
SELECT *
  FROM EMP
 WHERE SAL = SOME (SELECT MAX(SAL)
                     FROM EMP
                   GROUP BY DEPTNO);
--
--< ANY/SOME
--결과는 최대값보다 작은 것과 같다.
--950 1250 1500 1600 2850
SELECT *
  FROM EMP
 WHERE SAL < ANY (SELECT SAL --ANY는 하나만 만족해도 되는 것이기 때문에 위의 숫자 중에서 2850보다 작으면 어차피 다 커버되니까 최댓값보다 작으면으로 조건을 줘도 됨
                    FROM EMP
                   WHERE DEPTNO = 30)
                  ORDER BY SAL, EMPNO;
-- SOME도 ANY랑 똑같음
SELECT *
  FROM EMP
 WHERE SAL < SOME (SELECT SAL
                    FROM EMP
                   WHERE DEPTNO = 30)
                  ORDER BY SAL, EMPNO;
--단일행서브쿼리로 대체 -> 그냥 최대보다 작으면 된다로 단일행으로 주면 됨
SELECT *
  FROM EMP
 WHERE SAL < (SELECT MAX(SAL)
                    FROM EMP
                   WHERE DEPTNO = 30)
                  ORDER BY SAL, EMPNO;
                  
--> ANY/SOME
--결과는 최소값보다 큰 것과 같다.
--950 1250 1500 1600 2850
SELECT *
  FROM EMP
 WHERE SAL > ANY (SELECT SAL
                    FROM EMP
                   WHERE DEPTNO = 30)
                  ORDER BY SAL, EMPNO;
SELECT *
  FROM EMP
 WHERE SAL > SOME (SELECT SAL
                    FROM EMP
                   WHERE DEPTNO = 30)
                  ORDER BY SAL, EMPNO;
--단일행서브쿼리로 대체
SELECT *
  FROM EMP
 WHERE SAL > (SELECT MIN(SAL)
                    FROM EMP
                   WHERE DEPTNO = 30)
                  ORDER BY SAL, EMPNO;

--ALL 다중행 연산자
--< ALL
--결과는 최소값보다 작은 것과 같다.
--950 1250 1500 1600 2850
SELECT *
  FROM EMP
 WHERE SAL < ALL (SELECT SAL
                    FROM EMP
                   WHERE DEPTNO = 30);
--단일행서브쿼리로 대체
SELECT *
  FROM EMP
 WHERE SAL < (SELECT MIN(SAL)
                    FROM EMP
                   WHERE DEPTNO = 30);
                   
--> ALL
--결과는 최대값보다 큰 것과 같다.
--950 1250 1500 1600 2850
SELECT *
  FROM EMP
 WHERE SAL > ALL (SELECT SAL
                    FROM EMP
                   WHERE DEPTNO = 30);
--단일행서브쿼리로 대체
SELECT *
  FROM EMP
 WHERE SAL > (SELECT MAX(SAL)
                    FROM EMP
                   WHERE DEPTNO = 30);
--
--EXISTS 다중행 연산자
SELECT *
  FROM EMP
 WHERE EXISTS (SELECT DNAME
                 FROM DEPT
                WHERE DEPTNO = 10);
--
SELECT *
  FROM EMP
 WHERE EXISTS (SELECT DNAME
                 FROM DEPT
                WHERE DEPTNO = 50);
--다중열 서브쿼리 = 복수열 서브쿼리
--여러 개의 열을 비교하는 경우는 실무에서 꽤 많이 사용하므로 기억해두기
SELECT *
  FROM EMP
 WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL)
                           FROM EMP
                         GROUP BY DEPTNO);
--
--FROM절 뒤에서 사용하는 서브쿼리 = 인라인뷰
SELECT E10.EMPNO, E10.ENAME, E10.DEPTNO, D.DNAME, D.LOC
  FROM (SELECT * FROM EMP WHERE DEPTNO = 10) E10,
       (SELECT * FROM DEPT) D
 WHERE E10.DEPTNO = D.DEPTNO;
--인라인뷰가 많을 때는 WITH절로 먼저 별칭으로 선언해서 사용하면 가독성에 좋다.
WITH
E10 AS (SELECT * FROM EMP WHERE DEPTNO = 10),
D AS (SELECT * FROM DEPT)
SELECT E10.EMPNO, E10.ENAME, E10.DEPTNO, D.DNAME, D.LOC
  FROM E10, D
 WHERE E10.DEPTNO = D.DEPTNO;
--
--SELECT절에서 사용하는 서브쿼리 = 스칼라 서브쿼리
SELECT GRADE
          FROM EMP E, SALGRADE S
         WHERE E.SAL BETWEEN LOSAL AND HISAL;
SELECT DNAME
         FROM EMP E, DEPT
        WHERE E.DEPTNO = DEPT.DEPTNO;
--EMP E 가 FROM 절에 있으므로 서브쿼리 내에서는 EMP 테이블을 넣지 않아도 별칭 E 사용 가능
--서브쿼리 결과는 다른 열에서 나오는 행의 개수와 동일해야 함
SELECT EMPNO, ENAME, JOB, SAL,
       (SELECT GRADE
          FROM SALGRADE
         WHERE E.SAL BETWEEN LOSAL AND HISAL) AS SALGRADE,
       DEPTNO,
      (SELECT DNAME
         FROM DEPT
        WHERE E.DEPTNO = DEPT.DEPTNO) AS DNAME
FROM EMP E;

SELECT *
  FROM EMP
 WHERE SAL IN (SELECT MAX(SAL)
                 FROM EMP
               GROUP BY DEPTNO);
               
SELECT *
  FROM EMP
 WHERE SAL = ANY (SELECT MAX(SAL)
                    FROM EMP
                  GROUP BY DEPTNO);
                  
-- IN을 사용한 쿼리
SELECT *
FROM EMP
WHERE SAL > ANY (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);
-- ANY를 사용한 쿼리
SELECT *
FROM EMP
WHERE SAL > ANY (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);