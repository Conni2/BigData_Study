--
--개월수 차이, 과거가 미래보다 값이 작기 때문에 sysdate(오늘) - hiredate(입사일:과거)
SELECT EMPNO, ENAME, HIREDATE, SYSDATE,
       MONTHS_BETWEEN(HIREDATE, SYSDATE),
       MONTHS_BETWEEN(SYSDATE, HIREDATE),
       TRUNC(MONTHS_BETWEEN(SYSDATE, HIREDATE))
    FROM EMP;
--돌아오는 요일의 날짜
--해당 월의 마지막 날짜
SELECT SYSDATE, NEXT_DAY(SYSDATE, '금요일'), LAST_DAY(SYSDATE) FROM DUAL;

--

--날짜 반올림
SELECT SYSDATE,
       ROUND(SYSDATE, 'CC'),
       ROUND(SYSDATE, 'YYYY'),
       ROUND(SYSDATE, 'Q'),
       ROUND(SYSDATE, 'DDD'),
       ROUND(SYSDATE, 'HH')
    FROM DUAL;
--날짜 버리기
SELECT SYSDATE,
       TRUNC(SYSDATE, 'CC'),
       TRUNC(SYSDATE, 'YYYY'),
       TRUNC(SYSDATE, 'Q'),
       TRUNC(SYSDATE, 'DDD'),
       TRUNC(SYSDATE, 'HH')
    FROM DUAL;
--
--형변환함수
SELECT EMPNO, ENAME, EMPNO + '500' FROM EMP WHERE ENAME = 'SCOTT';
--숫자데이터를 따옴표로 묶어주면 문자데이터
--문자 데이터 500을 숫자로 인식해서 자동으로 숫자로 바꿔서 계산됨 = 자동형변환, 암시적형변환
SELECT 'ABC' + EMPNO, EMPNO FROM EMP WHERE ENAME = 'SCOTT';
--정말 문자 데이터이기 때문에 자동형변환이 안됨
--명시적형변환
--문자형변환
SELECT SYSDATE, TO_CHAR(SYSDATE, 'YYYY/MM/DD HH24:MI:SS') FROM DUAL;
--월일요일
SELECT SYSDATE,
       TO_CHAR(SYSDATE, 'MM'),
       TO_CHAR(SYSDATE, 'MON'),
       TO_CHAR(SYSDATE, 'MONTH'),
       TO_CHAR(SYSDATE, 'DD'),
       TO_CHAR(SYSDATE, 'DY'),
       TO_CHAR(SYSDATE, 'DAY')
    FROM DUAL;
SELECT SYSDATE,
       TO_CHAR(SYSDATE, 'MM'),
       TO_CHAR(SYSDATE, 'MON', 'NLS_DATE_LANGUAGE = KOREAN') AS K,
       TO_CHAR(SYSDATE, 'MON', 'NLS_DATE_LANGUAGE = JAPANESE') AS J,
       TO_CHAR(SYSDATE, 'MON', 'NLS_DATE_LANGUAGE = ENGLISH') AS E,
       TO_CHAR(SYSDATE, 'MONTH', 'NLS_DATE_LANGUAGE = KOREAN') AS K,
       TO_CHAR(SYSDATE, 'MONTH', 'NLS_DATE_LANGUAGE = JAPANESE') AS J,
       TO_CHAR(SYSDATE, 'MONTH', 'NLS_DATE_LANGUAGE = ENGLISH') AS E
    FROM DUAL;
-- 표시 언어를 바꾸기
SELECT SYSDATE,
       TO_CHAR(SYSDATE, 'DD'),
       TO_CHAR(SYSDATE, 'DY', 'NLS_DATE_LANGUAGE = KOREAN') AS K,
       TO_CHAR(SYSDATE, 'DY', 'NLS_DATE_LANGUAGE = JAPANESE') AS J,
       TO_CHAR(SYSDATE, 'DY', 'NLS_DATE_LANGUAGE = ENGLISH') AS E,
       TO_CHAR(SYSDATE, 'DAY', 'NLS_DATE_LANGUAGE = KOREAN') AS K,
       TO_CHAR(SYSDATE, 'DAY', 'NLS_DATE_LANGUAGE = JAPANESE') AS J,
       TO_CHAR(SYSDATE, 'DAY', 'NLS_DATE_LANGUAGE = ENGLISH') AS E
    FROM DUAL;
--숫자형식
SELECT SAL,
       TO_CHAR(SAL, '$999,999') AS SAL_$,
       TO_CHAR(SAL, 'L999,999') AS SAL_L,
       TO_CHAR(SAL, '999,999.00') AS SAL_1,
       TO_CHAR(SAL, '000,999,999.00') AS SAL_2,
       TO_CHAR(SAL, '000999999.99') AS SAL_3,
       TO_CHAR(SAL, '999,999,00') AS SAL_4
    FROM EMP;
--
--숫자형변환
SELECT 1300 - '1500', '1300' + 1500 FROM DUAL;
--1000 단위에 숫자가 찍혀있다고 알려줘야만 쉼표를 지움
SELECT '1,300' - '1,500' FROM DUAL;
-- 따라서 아래처럼 문자 있는 숫자! 라고 알려줘야함
SELECT TO_NUMBER('1,300', '999,999') - TO_NUMBER('1,500', '999,999') FROM DUAL;
--

--날짜형변환
SELECT TO_DATE('2018-07-14', 'YYYY-MM-DD') AS DATE1,
       TO_DATE('20180714', 'YYYY-MM-DD') AS DATE2
    FROM DUAL;
--날짜 비교 = 1981년 6월 1일 이후에 입사한 사람 (이후= 미래 = 6/1보다 더 커야함)
SELECT * FROM EMP WHERE HIREDATE > TO_DATE('1981/06/01', 'YYYY/MM/DD');
--날짜 비교 = 1981년 6월 1일 이전에 입사한 사람
SELECT * FROM EMP WHERE HIREDATE < TO_DATE('1981/06/01', 'YYYY/MM/DD');
--RR 1950~2049
SELECT TO_DATE('49/12/10', 'YY/MM/DD') AS Y1,
       TO_DATE('49/12/10', 'RR/MM/DD') AS Y2,
       TO_DATE('50/12/10', 'YY/MM/DD') AS Y3,
       TO_DATE('50/12/10', 'RR/MM/DD') AS Y4,
       TO_DATE('51/12/10', 'YY/MM/DD') AS Y5,
       TO_DATE('51/12/10', 'RR/MM/DD') AS Y6
    FROM DUAL;
--NULL 처리 함수
SELECT EMPNO, ENAME, SAL, COMM, SAL+COMM, NVL(COMM, 0), SAL+NVL(COMM, 0) FROM EMP;
--
SELECT EMPNO, ENAME, SAL, COMM, NVL2(COMM, 'O', 'X'), NVL2(COMM, SAL*12+COMM, SAL*12) FROM EMP;
--

--상황에 따라 다른 데이터 반환
--DECODE = 같다는 조건만 사용 가능
SELECT EMPNO, ENAME, JOB, SAL,
       DECODE(JOB,
              'MANAGER', SAL*1.1,
              'SALESMAN', SAL*1.05,
              'ANALYST', SAL,
              SAL*1.03) AS UPSAL
    FROM EMP;
--CASE = 같다는 조건 말고 다른 조건 사용 가능
SELECT EMPNO, ENAME, JOB, SAL,
    CASE JOB
        WHEN 'MANAGER' THEN SAL*1.1
        WHEN 'SALESMAN' THEN SAL*1.05
        WHEN 'ANALYST' THEN SAL
        ELSE SAL*1.03
    END AS UPSAL
  FROM EMP;
--
SELECT EMPNO, ENAME, COMM,
    CASE
        WHEN COMM IS NULL THEN '해당사항 없음'
        WHEN COMM = 0 THEN '수당 없음'
        WHEN COMM > 0 THEN '수당: ' || COMM
    END AS COMM_TXT
  FROM EMP;
--

--문제1
SELECT EMPNO,
       RPAD(SUBSTR(EMPNO,1,2),4,'*') AS MASKING_EMPNO,
       ENAME,
       RPAD(SUBSTR(ENAME,1,1),LENGTH(ENAME),'*') AS MASKING_ENAME
    FROM EMP
   WHERE LENGTH(ENAME) >= 5
     AND LENGTH(ENAME) < 6;
--문제2
SELECT EMPNO, ENAME, SAL,
       TRUNC(SAL/21.5,2) AS DAY_PAY,
       ROUND(SAL/21.5/8,1) AS TIME_PAY
    FROM EMP;
--문제3
SELECT EMPNO, ENAME, HIREDATE, 
        TO_CHAR(NEXT_DAY(ADD_MONTHS(HIREDATE,3),'월요일'),'YYYY-MM-DD') AS R_JOB, 
        NVL(TO_CHAR(COMM),'N/A') AS COMM
    FROM EMP;
--문제4
SELECT EMPNO, ENAME, MGR,
    CASE
       WHEN MGR IS NULL THEN '0000'
       WHEN SUBSTR(MGR,1,2) = '75' THEN '5555'
       WHEN SUBSTR(MGR,1,2) = '76' THEN '6666'
       WHEN SUBSTR(MGR,1,2) = '77' THEN '7777'
       WHEN SUBSTR(MGR,1,2) = '78' THEN '8888'
       ELSE TO_CHAR(MGR)
    END AS CHG_MGR
    FROM EMP;
--

--다중행함수 - 하나의 값으로 요약
--합계
SELECT SAL FROM EMP;
SELECT SUM(SAL) FROM EMP;
-- 얘는 행의 개수가 하나는 단일행이고(SUM) 나머지는 행이 많아서 붙어서 출력할 수가 없음!!!
SELECT ENAME, SUM(SAL) FROM EMP;

--NULL 값 제외하고 계산됨
SELECT SUM(COMM) FROM EMP;
-- 중복행 제거하고 더해보기
SELECT SUM(DISTINCT SAL),
       SUM(ALL SAL),
       SUM(SAL)
    FROM EMP;
--행의 갯수가 하나씩이기 때문에 붙을 수 있음
SELECT SUM(SAL), SUM(COMM) FROM EMP;
--

-- COUNT
SELECT COUNT(COMM) FROM EMP;
SELECT COUNT(COMM) FROM EMP WHERE COMM IS NOT NULL;
--최대값
SELECT MAX(SAL) FROM EMP;
SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 20;
SELECT MAX(HIREDATE) FROM EMP;
--최소값
SELECT MIN(SAL) FROM EMP;
SELECT MIN(SAL) FROM EMP WHERE DEPTNO = 30;
SELECT MIN(HIREDATE) FROM EMP;
--평균
SELECT AVG(SAL) FROM EMP;
SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 10; --10번 부서 근무한 사람들만 뽑아서 평균
SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 20; --20번 부서에서 근무한 사람들만 뽑아서 평균
SELECT AVG(DISTINCT SAL) FROM EMP WHERE DEPTNO = 20; -- DISTINCT도 쓸 수 있음
SELECT AVG(COMM) FROM EMP;
SELECT AVG(COMM) FROM EMP WHERE DEPTNO = 30;
--
--그룹별로 원래는 하나씩 다 찾아서
SELECT DISTINCT DEPTNO FROM EMP;
SELECT * FROM EMP WHERE DEPTNO = 10;
SELECT * FROM EMP WHERE DEPTNO = 20;
SELECT * FROM EMP WHERE DEPTNO = 30;
-- 여기에 넣어서 UNION ALL로 각각 묶어야함 (힘듦)
SELECT AVG(SAL), '10' AS DEPTNO FROM EMP WHERE DEPTNO = 10
UNION ALL
SELECT AVG(SAL), '20' AS DEPTNO FROM EMP WHERE DEPTNO = 20
UNION ALL
SELECT AVG(SAL), '30' AS DEPTNO FROM EMP WHERE DEPTNO = 30;
--하지만 GROUP BY를 써서 너무 쉽게!! 할 수 있음
SELECT AVG(SAL), DEPTNO FROM EMP GROUP BY DEPTNO;
SELECT AVG(SAL), DEPTNO FROM EMP GROUP BY DEPTNO ORDER BY DEPTNO;
--또 다른 예제: DEPTNO와 JOB을 함께 묶어서 하나의 그룹이됨 (예시: 10과 CLERK)
SELECT DISTINCT DEPTNO, JOB FROM EMP ORDER BY DEPTNO, JOB;
-- 위의 것을 아래와 같이 GROUP BY 로 쓸 수 있음
SELECT DEPTNO, JOB, AVG(SAL)
    FROM EMP
    GROUP BY DEPTNO, JOB
    ORDER BY DEPTNO, JOB;
--부서번호로 묶어서 평균값 보기 -> 30만 COMM 값있음
SELECT DEPTNO, AVG(COMM) FROM EMP GROUP BY DEPTNO;
--GROUP BY 는 SELECT 절에도 똑같이 써야함 -> 여기는 지금 SELECT에 DEPTNO말고 ENAME이 들어가있음
SELECT ENAME, DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO;

--GROUP BY HAVING 조건
SELECT DEPTNO, JOB, AVG(SAL) FROM EMP GROUP BY DEPTNO, JOB ORDER BY DEPTNO, JOB;
-- GROUP화 된 결과에서 조건을 걸어서 보고 싶은 것만 보고싶을 때
SELECT DEPTNO, JOB, AVG(SAL) FROM EMP
    GROUP BY DEPTNO, JOB
    HAVING AVG(SAL) >= 2000
    ORDER BY DEPTNO, JOB;
-- GROUP BY 실행되기 전에 WHERE가 실행되기 때문에 WHERE절 먼저 적용이 되어버림
SELECT DEPTNO, JOB, AVG(SAL) FROM EMP
    WHERE AVG(SAL) >= 2000
    GROUP BY DEPTNO, JOB
    ORDER BY DEPTNO, JOB;
-- 위의 것을 고치면,
SELECT DEPTNO, JOB, AVG(SAL) FROM EMP
    WHERE SAL <= 3000
    GROUP BY DEPTNO, JOB
    HAVING AVG(SAL) >= 2000
    ORDER BY DEPTNO, JOB;
--

--리스트로 합치기
SELECT ENAME FROM EMP WHERE DEPTNO = 10;
SELECT DEPTNO, ENAME FROM EMP GROUP BY DEPTNO, ENAME ORDER BY DEPTNO, ENAME;
SELECT DEPTNO,
       LISTAGG(ENAME, ', ') -- 파이썬 JOIN처럼 각 이름을 구분자로 합쳐줌
       WITHIN GROUP(ORDER BY SAL DESC) AS ENAMES --이 그룹 안에서~ WITHIN (ORDER BY -> 정렬해줘!) : 그룹 안에서 급여 순대로 이름을 정리해줘
    FROM EMP
    GROUP BY DEPTNO;
SELECT DEPTNO,
       LISTAGG(ENAME, ', ')
       WITHIN GROUP(ORDER BY ENAME) AS ENAMES -- 다른 기준을 가지고 ORDER 해봤음
    FROM EMP
    GROUP BY DEPTNO;
--
SELECT LISTAGG(ENAME, ', ') -- 이거는 그룹짓고 나서 LISTAGG한게 아니라 전체 이름을 다 LISTAGG 하겠다는 것
       WITHIN GROUP(ORDER BY ENAME) AS ENAMES 
    FROM EMP;